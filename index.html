<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft æ•´åˆåŒ…ç®¡ç†å™¨</title>
    <style>
        :root {
            --primary: #6366f1;
            --background: #f8fafc;
            --surface: #ffffff;
            --border: #e2e8f0;
        }

        body {
            font-family: 'Inter', -apple-system, system-ui, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--background);
            line-height: 1.6;
        }

        .card {
            background: var(--surface);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
        }

        .file-item {
            display: grid;
            grid-template-columns: minmax(200px, 1fr) 2fr 100px;
            align-items: center;
            gap: 1.5rem;
            padding: 1rem;
            margin: 0.5rem 0;
            background: var(--background);
            border-radius: 0.75rem;
        }

        .path-display {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            color: #475569;
        }

        .url {
            color: var(--primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .badge {
            padding: 0.35rem 0.8rem;
            border-radius: 6px;
            font-size: 0.85rem;
            text-align: center;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <h1>ğŸ› ï¸ æ•´åˆåŒ…ç®¡ç†å™¨ <span id="version" class="badge" style="background: #6366f1; color: white"></span></h1>
    <div id="loading" class="card">æ­£åœ¨åŠ è½½æ›´æ–°ä¿¡æ¯...</div>
    <div id="file-list"></div>

    <script>
        // é…ç½®ç®¡ç†å™¨
        const CONFIG = {
            CACHE_KEY: 'mc_patch_v3',
            CACHE_TTL: 300000, // 5åˆ†é’Ÿç¼“å­˜
            REPO_PATH: 'https://raw.githubusercontent.com/cleanper/UpdatePath/main/patch.json',
            FALLBACK_DATA: {
                download: { additions: [], deletions: [] },
                replace: []
            }
        };

        // å®‰å…¨æ•°æ®è·å–å™¨
        class DataFetcher {
            static async fetch() {
                try {
                    // å°è¯•è¯»å–ç¼“å­˜
                    const cached = this._getCache();
                    if (cached) return cached;

                    // å‘èµ·ç½‘ç»œè¯·æ±‚
                    const response = await fetch(CONFIG.REPO_PATH + '?t=' + Date.now());
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    // ä¸¥æ ¼JSONè§£æ
                    const data = await this._parseJSON(response);
                    this._setCache(data);
                    return data;
                } catch (error) {
                    console.warn('ç½‘ç»œè¯·æ±‚å¤±è´¥:', error);
                    return this._getCache() || CONFIG.FALLBACK_DATA;
                }
            }

            static _parseJSON(response) {
                return response.json().then(data => {
                    // JSONç»“æ„éªŒè¯
                    if (!data.download || !Array.isArray(data.replace)) {
                        throw new Error('æ— æ•ˆçš„JSONç»“æ„');
                    }
                    return data;
                });
            }

            static _getCache() {
                try {
                    const cache = localStorage.getItem(CONFIG.CACHE_KEY);
                    if (!cache) return null;
                    
                    const { expires, data } = JSON.parse(cache);
                    return Date.now() < expires ? data : null;
                } catch {
                    return null;
                }
            }

            static _setCache(data) {
                try {
                    localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify({
                        expires: Date.now() + CONFIG.CACHE_TTL,
                        data: data
                    }));
                } catch (error) {
                    console.warn('æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
                }
            }
        }

        // ç•Œé¢æ¸²æŸ“å™¨
        class Renderer {
            static init() {
                this.fileList = document.getElementById('file-list');
                this.loading = document.getElementById('loading');
            }

            static async render() {
                try {
                    const data = await DataFetcher.fetch();
                    this._clearLoading();
                    this._renderVersion(data);
                    this._renderSections(data);
                } catch (error) {
                    this._showError(error);
                }
            }

            static _renderVersion(data) {
                const version = data.download?.version || 'æœªçŸ¥';
                document.getElementById('version').textContent = `v${version}`;
            }

            static _renderSections(data) {
                const fragment = document.createDocumentFragment();
                
                if (data.download.deletions?.length) {
                    fragment.appendChild(this._buildSection(
                        'ğŸ—‘ï¸ å¾…åˆ é™¤æ–‡ä»¶',
                        data.download.deletions.map(file => 
                            this._buildFileItem(
                                `mods/${file}`,
                                'å¾…åˆ é™¤',
                                'delete'
                            )
                        )
                    ));
                }

                if (data.download.additions?.length) {
                    fragment.appendChild(this._buildSection(
                        `ğŸ“¥ ä¸‹è½½æ›´æ–° (${data.download.additions.length}ä¸ªæ–‡ä»¶)`,
                        data.download.additions.map(file => 
                            this._buildFileItem(
                                `mods/${file.name}`,
                                file.url,
                                'download',
                                file.url
                            )
                        )
                    ));
                }

                if (data.replace?.length) {
                    fragment.appendChild(this._buildSection(
                        'ğŸ”„ æ–‡ä»¶æ›¿æ¢',
                        data.replace.map(file => 
                            this._buildFileItem(
                                `config/${file.oldName} â†’ ${file.newUrl.split('/').pop()}`,
                                file.newUrl,
                                'replace'
                            )
                        )
                    ));
                }

                this.fileList.appendChild(fragment);
            }

            static _buildSection(title, items) {
                const section = document.createElement('div');
                section.className = 'card';
                section.innerHTML = `
                    <h2 style="margin: 0 0 1rem 0">${title}</h2>
                    ${items.join('')}
                `;
                return section;
            }

            static _buildFileItem(pathText, url, type) {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <div class="path-display">${this._sanitize(pathText)}</div>
                    <a href="${this._sanitize(url)}" target="_blank" class="url">${this._getHostname(url)}</a>
                    <div class="badge" style="${this._getBadgeStyle(type)}">
                        ${this._getActionText(type)}
                    </div>
                `;
                return item;
            }

            static _getHostname(url) {
                try {
                    return new URL(url).hostname;
                } catch {
                    return 'æ— æ•ˆé“¾æ¥';
                }
            }

            static _getBadgeStyle(type) {
                const colors = {
                    delete: 'background: #ef4444; color: white',
                    download: 'background: #3b82f6; color: white',
                    replace: 'background: #10b981; color: white'
                };
                return colors[type] || '';
            }

            static _getActionText(type) {
                return {
                    delete: 'åˆ é™¤',
                    download: 'ä¸‹è½½',
                    replace: 'æ›¿æ¢'
                }[type] || '';
            }

            static _sanitize(text) {
                return text.toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
            }

            static _clearLoading() {
                this.loading.remove();
            }

            static _showError(error) {
                this.fileList.innerHTML = `
                    <div class="card" style="background: #fee2e2; color: #dc2626">
                        <h3>âš ï¸ åŠ è½½å¤±è´¥</h3>
                        <p>${this._sanitize(error.message)}</p>
                        <button onclick="window.location.reload()" 
                            style="margin-top: 0.5rem;
                                   padding: 0.5rem 1rem;
                                   background: #dc2626;
                                   color: white;
                                   border: none;
                                   border-radius: 0.375rem;">
                            é‡è¯•
                        </button>
                    </div>
                `;
            }
        }

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            Renderer.init();
            Renderer.render();
        });
    </script>
</body>
</html>
